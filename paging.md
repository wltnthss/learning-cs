## 페이징 기법

프로세스를 메모리에 연속적으로 할당하는 방식은 두 가지 문제를 내포함.

한 가지는 외부 단편화 , 다른 한 가지는 물리 메모리보다 큰 프로세스를 실행할 수 없다는 점임.

외부 단편화가 생기는 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문임.

페이징은 메모리와 프로세스를 일정한 단위로 자르고, 불연속적으로 할당함.

페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자름.

메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 프레임에 할당하는 가상 메모리 관리 기법이 페이징임.

페이징은 스와핑과 같은 구조로 페이지 아웃, 페이지 인하며 보조기억장치와의 스왑이 이루어짐.

```
즉, 페이징은 한 프로세스를 실행할 때 전체가 메모리에 적재될 필요가 없으므로, 프로세스의 일부 페이지를 메모리에 적재,
실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둠으로써, 물리 메모리보다 더 큰 프로세스를 실행할 수 있음.
```

### 페이징 테이블 

프로세스가 메모리에 불연속적으로 배치되어 있는 경우 CPU는 다음에 실행할 명령어 위치를 찾기가 어려워짐.

이를 해결하기 위한 것이 CPU가 바라보는 논리 주소에 연속적으로 배치하는 페이지 테이블임.
(페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표)

![image](https://github.com/wltnthss/learning-cs/assets/60785586/933484a2-c3cb-4f27-bda7-2bdea0621e8d)

위 그림과 같이 페이지 테이블이 페이지가 어디 프레임에 있는지 알려줌 (배열과 유사)

CPU 내의 페이지 테이블 베이스 레지스터(PTBR) 은 각 프로세스의 페이지 테이블이 적재된 주소를 가르침.

이러한 각 프로세스들의 페이지 테이블 정보들은 PCB에 기록되며, 문맥 교환이 일어날 떄 다른 레지스터와 마찬가지로 변경.

하지만 페이지 테이블을 메모리에 두면 메모리 접근 시간이 두 배로 늘어난다는 단점이 있음. 
(메모리에 있는 페이지 테이블을 보기 위해 한 번, 알게 된 프레임에 접근하기 위해 한 번)

이를 해결 하기 위해 CPU곁에 TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 둠.

페이지 테이블의 일부 내용을 저장하고, 최근에 사용된 페이지 위주로 가져와 저장함.

논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 TLB 히트라고함.

이 경우 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없음.(한번만 접근하면 됨)

TLB가 없는 경우는 어쩔 수 없이 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근하는 수 밖에 없는데,

이를 TBL 미스라고 함.

### 페이징에서의 주소 변환

프레임은 여러 주소를 포괄하고 있는데, 이에 접근하기 위해서는 두 가지 정보가 필요함.

- 어떤 페이지 or 프레임에 접근하고 싶은지

- 접근하려는 주소가 그 페이지 or 프레임으로부터 얼마나 떨어져 있는지

페이징 시스템에서는 모든 논리 주소가 페이지 번호와 변위로 이루어져 있음.

ex) CPU 가 32 bit 주소를 보낸 경우 N 비트는 페이지 번호, 32-N 은 변위

페이지 번호는 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지를 알 수 있고,

변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보임.

즉, 논리 주소 < 페이지 번호, 변위 > -> (페이지 테이블) 물리주소 < 프레임 번호, 변위 > 로 변환됨.

### 페이지 테이블 엔트리

페이지 테이블의 각각의 행들을 페이지 테이블 엔트리라고함.

페이지 테이블 엔트리에는 페이지 번호, 프레임 번호 이외에도 유효 비트, 보호 비트, 참조 비트, 수정 비트가 존재함.

##### 유효 비트

유효 비트는 현재 해당 페이지에 접근 가능한지 여부를 알려줌.

일반적으로 프로세스를 이루는 페이지에는 스왑 영역(보조기억장치)에 있을 수도 있고, 메모리에 있을 수도 있음.
(유효비트가 이를 알려주는 비트임)

즉, 메모리에 적재되어있으면 유효 비트는 1, 적재되어 있지 않다면 0 임.

이 때, 만일 유효 비트가 0인 메모리의 페이지로 접근할 경우 페이지 폴트라는 예외가 발생함.

#### 보호 비트

보호 비트는 페이지 보호 기능을 위해 존재하는 비트임.

보호 비트를 통해 읽고 쓰기가 가능한지, 읽기만 가능한지를 나타내주는데

1일 경우 읽고 쓰기가 가능하며, 0일 경우 읽기만 가능한지를 나타내줌.

실제로 보호비트를 응용할 때는 읽기 r, 쓰기 w, 실행 x로 나누어 이진법으로써 사용함.

#### 참조 비트

참조 비트는 CPU가 페이지에 접근한 적이 있는지 여부를 나타냄.

적재 이후 CPU가 읽거나 쓴 페이지는 참조 비트가 1이고, 한 번도 읽거나 쓴 적이 없는 페이지는 0으로 유지됨.

#### 수정 비트

수정 비트는 더티 비트라고도 부르며 수정된 적이 있으면 1, 없으면 0으로 나타냄.

수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 없는지 판단하기위해 존재함.



